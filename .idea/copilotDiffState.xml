<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/jejelegagnant/catorcar/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/jejelegagnant/catorcar/MainActivity.java" />
              <option name="originalContent" value="package com.jejelegagnant.catorcar;&#10;&#10;import android.media.Image;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.widget.Button;&#10;import android.widget.Toast;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import org.tensorflow.lite.DataType;&#10;import org.tensorflow.lite.Interpreter;&#10;import org.tensorflow.lite.support.common.FileUtil;&#10;import org.tensorflow.lite.support.image.TensorImage;&#10;import org.tensorflow.lite.support.image.ImageProcessor;&#10;import org.tensorflow.lite.support.image.ops.ResizeOp;&#10;import org.tensorflow.lite.support.tensorbuffer.TensorBuffer;&#10;&#10;import android.graphics.Bitmap;&#10;import android.graphics.BitmapFactory;&#10;&#10;import java.io.IOException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;&#10;        setupAnalyzeButton();&#10;        setupWindowInsets();&#10;    }&#10;&#10;    private void setupAnalyzeButton() {&#10;        Button analyzeButton = findViewById(R.id.button);&#10;        analyzeButton.setOnClickListener(v -&gt; onAnalyzeButtonClick());&#10;    }&#10;&#10;    private void onAnalyzeButtonClick() {&#10;        Log.d(&quot;MainActivity&quot;, &quot;Le bouton a été cliqué !&quot;);&#10;        Toast.makeText(MainActivity.this, &quot;Analyse en cours...&quot;, Toast.LENGTH_SHORT).show();&#10;&#10;        int inputSize = 260;&#10;        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sport_car);&#10;&#10;        Interpreter tflite = null;&#10;        try {&#10;            tflite = new Interpreter(FileUtil.loadMappedFile(this, &quot;2.tflite&quot;));&#10;            List&lt;String&gt; labels = FileUtil.loadLabels(this, &quot;labels.txt&quot;);&#10;&#10;            int[] inputShape = tflite.getInputTensor(0).shape();&#10;            DataType inputType = tflite.getInputTensor(0).dataType();&#10;            Log.d(&quot;Model&quot;, &quot;Input shape: &quot; + Arrays.toString(inputShape));&#10;            Log.d(&quot;Model&quot;, &quot;Input type: &quot; + inputType.name());&#10;&#10;            TensorImage tensorImage = preprocessImage(bitmap, inputSize, inputType);&#10;&#10;            int[] outputShape = tflite.getOutputTensor(0).shape();&#10;            DataType outputType = tflite.getOutputTensor(0).dataType();&#10;            TensorBuffer outputBuffer = TensorBuffer.createFixedSize(outputShape, outputType);&#10;&#10;            Log.d(&quot;Model&quot;, &quot;Output shape: &quot; + Arrays.toString(outputShape));&#10;            Log.d(&quot;Model&quot;, &quot;Output type: &quot; + outputType.name());&#10;&#10;            tflite.run(tensorImage.getBuffer(), outputBuffer.getBuffer());&#10;&#10;            handlePredictionResult(outputBuffer, labels);&#10;&#10;        } catch (IOException e) {&#10;            Toast.makeText(this, &quot;Erreur lors du chargement du modèle&quot;, Toast.LENGTH_LONG).show();&#10;            Log.e(&quot;Model&quot;, &quot;Erreur chargement modèle&quot;, e);&#10;        } finally {&#10;            if (tflite != null) {&#10;                tflite.close();&#10;            }&#10;        }&#10;    }&#10;&#10;    private TensorImage preprocessImage(Bitmap bitmap, int inputSize, DataType inputType) {&#10;        TensorImage tensorImage = new TensorImage(inputType);&#10;        tensorImage.load(bitmap);&#10;&#10;        ImageProcessor.Builder processorBuilder = new ImageProcessor.Builder()&#10;                .add(new ResizeOp(inputSize, inputSize, ResizeOp.ResizeMethod.BILINEAR));&#10;&#10;        if (inputType == DataType.FLOAT32) {&#10;            processorBuilder.add(new NormalizeOp(0f, 255f));&#10;        }&#10;&#10;        ImageProcessor imageProcessor = processorBuilder.build();&#10;        return imageProcessor.process(tensorImage);&#10;    }&#10;&#10;    private void handlePredictionResult(TensorBuffer outputBuffer, List&lt;String&gt; labels) {&#10;        float[] scores = outputBuffer.getFloatArray();&#10;&#10;        int maxIdx = 0;&#10;        for (int i = 1; i &lt; scores.length; i++) {&#10;            if (scores[i] &gt; scores[maxIdx]) maxIdx = i;&#10;        }&#10;&#10;        String result = labels.get(maxIdx);&#10;        float confidence = scores[maxIdx];&#10;&#10;        Log.d(&quot;Prediction&quot;, &quot;Top label: &quot; + result + &quot; (score=&quot; + confidence + &quot;)&quot;);&#10;        Log.d(&quot;Prediction&quot;, &quot;All scores: &quot; + Arrays.toString(scores));&#10;&#10;        Toast.makeText(this, &quot;Prédit : &quot; + result + &quot;\n(Confiance : &quot; + confidence + &quot;)&quot;, Toast.LENGTH_LONG).show();&#10;        if (isIndexCar(maxIdx)){&#10;            Toast.makeText(this, &quot;C'est une voiture !&quot;, Toast.LENGTH_SHORT).show();&#10;        } else if (isIndexCat(maxIdx)) {&#10;            Toast.makeText(this, &quot;C'est un chat !&quot;, Toast.LENGTH_SHORT).show();&#10;        } else {&#10;            Toast.makeText(this, &quot;Ce n'est ni un chat ni une voiture.&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;    private boolean isIndexCat(int index) {&#10;        // Vérifie si l'index correspond à un label de chat&#10;        return index &gt; 281 &amp;&amp; index &lt; 295 || index == 384;&#10;    }&#10;    private boolean isIndexCar(int index) {&#10;        // Vérifie si l'index correspond à un label de voiture&#10;        return index == 437 || index == 469 || index == 512 || index == 610 || index == 620 || index == 657&#10;                || index == 662 || index == 706 || index == 718 || index == 752 || index == 758 || index == 818;&#10;    }&#10;&#10;    private void setupWindowInsets() {&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package com.jejelegagnant.catorcar;&#10;&#10;import android.media.Image;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.widget.Button;&#10;import android.widget.Toast;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import org.tensorflow.lite.DataType;&#10;import org.tensorflow.lite.Interpreter;&#10;import org.tensorflow.lite.support.common.FileUtil;&#10;import org.tensorflow.lite.support.image.TensorImage;&#10;import org.tensorflow.lite.support.image.ImageProcessor;&#10;import org.tensorflow.lite.support.image.ops.ResizeOp;&#10;import org.tensorflow.lite.support.tensorbuffer.TensorBuffer;&#10;&#10;import android.graphics.Bitmap;&#10;import android.graphics.BitmapFactory;&#10;&#10;import java.io.IOException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;&#10;        setupAnalyzeButton();&#10;        setupWindowInsets();&#10;    }&#10;&#10;    private void setupAnalyzeButton() {&#10;        Button analyzeButton = findViewById(R.id.button);&#10;        analyzeButton.setOnClickListener(v -&gt; onAnalyzeButtonClick());&#10;    }&#10;&#10;    private void onAnalyzeButtonClick() {&#10;        Log.d(&quot;MainActivity&quot;, &quot;Le bouton a été cliqué !&quot;);&#10;        Toast.makeText(MainActivity.this, &quot;Analyse en cours...&quot;, Toast.LENGTH_SHORT).show();&#10;&#10;        int inputSize = 260;&#10;        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sport_car);&#10;&#10;        Interpreter tflite = null;&#10;        try {&#10;            tflite = new Interpreter(FileUtil.loadMappedFile(this, &quot;2.tflite&quot;));&#10;            List&lt;String&gt; labels = FileUtil.loadLabels(this, &quot;labels.txt&quot;);&#10;&#10;            int[] inputShape = tflite.getInputTensor(0).shape();&#10;            DataType inputType = tflite.getInputTensor(0).dataType();&#10;            Log.d(&quot;Model&quot;, &quot;Input shape: &quot; + Arrays.toString(inputShape));&#10;            Log.d(&quot;Model&quot;, &quot;Input type: &quot; + inputType.name());&#10;&#10;            TensorImage tensorImage = preprocessImage(bitmap, inputSize, inputType);&#10;&#10;            int[] outputShape = tflite.getOutputTensor(0).shape();&#10;            DataType outputType = tflite.getOutputTensor(0).dataType();&#10;            TensorBuffer outputBuffer = TensorBuffer.createFixedSize(outputShape, outputType);&#10;&#10;            Log.d(&quot;Model&quot;, &quot;Output shape: &quot; + Arrays.toString(outputShape));&#10;            Log.d(&quot;Model&quot;, &quot;Output type: &quot; + outputType.name());&#10;&#10;            tflite.run(tensorImage.getBuffer(), outputBuffer.getBuffer());&#10;&#10;            handlePredictionResult(outputBuffer, labels);&#10;&#10;        } catch (IOException e) {&#10;            Toast.makeText(this, &quot;Erreur lors du chargement du modèle&quot;, Toast.LENGTH_LONG).show();&#10;            Log.e(&quot;Model&quot;, &quot;Erreur chargement modèle&quot;, e);&#10;        } finally {&#10;            if (tflite != null) {&#10;                tflite.close();&#10;            }&#10;        }&#10;    }&#10;&#10;    private TensorImage preprocessImage(Bitmap bitmap, int inputSize, DataType inputType) {&#10;        TensorImage tensorImage = new TensorImage(inputType);&#10;        tensorImage.load(bitmap);&#10;&#10;        ImageProcessor.Builder processorBuilder = new ImageProcessor.Builder()&#10;                .add(new ResizeOp(inputSize, inputSize, ResizeOp.ResizeMethod.BILINEAR));&#10;&#10;        if (inputType == DataType.FLOAT32) {&#10;            processorBuilder.add(new NormalizeOp(0f, 255f));&#10;        }&#10;&#10;        ImageProcessor imageProcessor = processorBuilder.build();&#10;        return imageProcessor.process(tensorImage);&#10;    }&#10;&#10;    private void handlePredictionResult(TensorBuffer outputBuffer, List&lt;String&gt; labels) {&#10;        float[] scores = outputBuffer.getFloatArray();&#10;&#10;        int maxIdx = 0;&#10;        for (int i = 1; i &lt; scores.length; i++) {&#10;            if (scores[i] &gt; scores[maxIdx]) maxIdx = i;&#10;        }&#10;&#10;        String result = labels.get(maxIdx);&#10;        float confidence = scores[maxIdx];&#10;&#10;        Log.d(&quot;Prediction&quot;, &quot;Top label: &quot; + result + &quot; (score=&quot; + confidence + &quot;)&quot;);&#10;        Log.d(&quot;Prediction&quot;, &quot;All scores: &quot; + Arrays.toString(scores));&#10;&#10;        Toast.makeText(this, &quot;Prédit : &quot; + result + &quot;\n(Confiance : &quot; + confidence + &quot;)&quot;, Toast.LENGTH_LONG).show();&#10;        if (isIndexCar(maxIdx)){&#10;            Toast.makeText(this, &quot;C'est une voiture !&quot;, Toast.LENGTH_SHORT).show();&#10;        } else if (isIndexCat(maxIdx)) {&#10;            Toast.makeText(this, &quot;C'est un chat !&quot;, Toast.LENGTH_SHORT).show();&#10;        } else {&#10;            Toast.makeText(this, &quot;Ce n'est ni un chat ni une voiture.&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;    private boolean isIndexCat(int index) {&#10;        // Vérifie si l'index correspond à un label de chat&#10;        return index &gt; 280 &amp;&amp; index &lt; 294 || index == 383;&#10;    }&#10;    private boolean isIndexCar(int index) {&#10;        // Vérifie si l'index correspond à un label de voiture&#10;        return index == 436 || index == 468 || index == 511 || index == 609 || index == 619 || index == 656&#10;                || index == 661 || index == 705 || index == 717 || index == 751 || index == 757 || index == 817;&#10;    }&#10;&#10;    private void setupWindowInsets() {&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>